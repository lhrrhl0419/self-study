# 6.031 Software Construction

1. **Static Checking**
    * In Java, primitive types: lowercase, object types: start with a capital letter  
    * Static typing
    * Documenting assumptions
    * Safe from bugs
    * Easy to understand
    * Ready for change

2. **Basic Java**
    * Snapshot diagrams

3. **Testing**
    * Validation
    * Formal reasoning
    * Code review
    * Module: can be separated from the rest of the system
    * Specification: the behavior of a module
    * Implementation: provide its behavior(body of the method)
    * Clients: use the module(other code that calls the method)
    * Test-first programming: Spec-Test-Implement
    * Systematic testing
    * Choosing test cases by partitioning
        * Disjoint, Complete and Correct
    * Boundaries
    * Multiple partitions
    * Unit testing and Integration testing
    * Black box testing and Glass box testing
    * Coverage: Statement, Branch, Path
    * Automated regression testing
    * Iterative test-first programming

4. **Code Review**
    * Don't repeat yourself(DRY)
    * Comments where needed
    * Fail fast
    * Avoid magic numbers
    * Don't reuse parameters and variables
    * Use long and self-descriptive names
    * Method or variable name: snake_case(Python), camelCase(Java)
    * ALL_CAPS_WITH_UNDERSCORES(public static final)
    * Method names: verb phrases
    * Short words, concise, no abbreviations
    * Avoid single-character variable names entirely except where they are easily understood by convention
    * Avoid global variables
    * Avoid special-case code

5. **Version Control**
   * Git

6. **Specifications**
   * Exception
   * Behavioral equivalence
   * Specification structure
        * Method signature: Name, Parameter types, Return type and Exceptions thrown
        * Requires clause: Additional restrictions on the parameters
        * Effects Clause: Return value, exceptions and other effects of the method
        * In Java, they are changed into @param, @return and @throws
   * Null values are usually disallowed in parameters and return values
   * Unit tests and Integration tests
   * Mutation is disallowed unless stated otherwise
   * Use exceptions to handle special results instead of special values
   * Checked exceptions to signal special results and Unchecked exceptions to signal bugs

7. **Designing Specifications**
    * Deterministic vs. Underdetermined specs
    * Declarative vs. Operational specs
    * Stronger vs. Weaker specs
    * Coherent, Informative, Strong, Weak, Abstract
    * Access control
    * Static vs. Instance methods

8. **Mutability & Immutability**
    * How much sharing is possible and How much copying is required
    * Mutability:
        * Performance, Convenience
        * Risks of bugs

9. **Avoiding Debugging**
    * Make bugs impossible
        * Static checking
        * Dynamic checking
        * Immutability
    * Localize bugs
        * Fail fast
    * Assertions
        * Method argument / return value requirements
    * Incremental development
    * Modularity & encapsulation

10. **Abstract Data Types**
    * Abstractioin, Modularity, Encapsulation, Information hiding, Separation of concerns
    * Type is characterized by the operations one can perform on it
    * Creators, Producers, Observers, Mutators
    * Designing an abstract type
        * A few, simple operations used to combine
        * Coherent behavior
        * Adequate: enough to do the kinds of computations clients are likely to want to do
        * Do not mix generic and domain-specific features
    * Representation independent: The use of an abstract type is independent of its representation

11. **Abstraction Functions & Rep Invariants**
    * Preserve its own invariants
    * Immutable wrappers around mutable data types
    * Abstraction function: R -> A
    * Rep invariant: R -> Bool
    * Safety from rep exposure comment
    * ADT specification
        * Specs of its operations(visible to the client: parameters, return values, exceptions)
    * ADT invariants replace preconditions

12. **Defining ADTs with Interfaces, Generics, Enums, and Functions**
    * Interfaces
        * Documentation for both the compiler and for humans
        * Allowing performance trade-offs
        * Methods with intentionally underdetermined specifications
        * Multiple view of one class
        * More and less trustworthy implementations
    * Subtypes
    * Dynamic dispatch
    * Generic types
    * Enumerations

13. **Debugging**
    * Reproduce the bug
    * Scientific method
        * Study the data
        * Hypothesize
            * Slicing
            * Delta debugging
            * Prioritize hypotheses
        * Experiment
        * Repeat
            * Keep an audit trail

14. **Recursion**
    * Recursion function
        * Base case
        * Recursive step
    * Recursion as decomposition
    * Helper method
    * Reenterant code
    * Functional programming

15. **Equality**
    * Equality of immutable types
        * Abstraction function
    * Override equals()
    * The object contract
    * Always override hashCode when overriding equals
    * Observational equality and Behavioral equality
    * Equals() should implement behavioral equality
        * For immutable types: override equals() and hashCode()
        * For mutable types: Don't override equals() and hashCode(), but define a new operation like sameValue() instead

16. **Recursive Data Types**
    * Document recursive type definition, for example: Tree\<E\> = Empty + Node(e:E, left:Tree\<E\>, right:Tree\<E\>)

17. **Regular Expressions & Grammars**

18. **Parsers**

19. **Writing a Program with Abstract Data Types**
    * Writing an abstract data type
        * Spec
        * Test
        * Implement
            * Choose rep
            * Assert rep invariant by implementing a checkRep()
            * Implement operations

20. **Concurrency**
    * Shared memory: interact by reading and writing shared objects in memory
    * Message passing: concurrent modules interact by sending messages to each other through a communication channel
    * Processes, threads, time-slicing
    * Anonymous class
    * Interleaving
    * Heisenbug and Bohrbug

21. **Thread Safety**
    * Threadsafe:
        * Behaves correctly
        * Regardless of how threads are executed
        * Without additioinal coordination
    * Confinement: keeping the references or data confined to a single thread
    * Immutability
    * Threadsafe data types
    * Safety argument
    * Serializability

22. **Locks and Synchronization**
    * Locks: Acquire and release
    * Deadlock
    * All accesses to a data variable must be guarded by the same lock
    * Locking discipline
        * Every shared mutable variable must be guarded by some lock
        * If an invariant involves multiple shared mutable variables, then all the variables involved must be guarded by the same lock
    * Lock ordering
    * Coarse-grained locking

23. **Queues and Message-Passing**
    * Existing threadsafe data types
    * Immutability
    * Confinement of data to individual producer/consumer threads
    * Confinement of mutable messages or data that are sent over the queue but will only be accessible to one thread at a time
    * Timeouts exception

24. **Sockets & Networking**

25. **Callbacks**
    * Listener pattern
    * First-class functions
        * Functional object in Java
    * Concurrency

26. **Map, Filter, Reduce**
    * Stream\<E\>

27. **Little Language I**
    * Building languages to solve problems: Domain-specific language (DSL)
    * Composite pattern: single objects and groups of objects all belong to the same type and be treated the same way

28. **Little Language II**
    * Interpreter pattern and Vistor pattern
    * Interpreter pattern:
        * Declare the operation as an instance method in the interface that defines the datatype
        * Implement the operation in each concrete variant
        * Hard to find the code which implements the operation
        * Hard to add a new operation
        * Easy to add new variants
    * Visitor pattern
        * Easy to add new operatioins, both for the author and the clients
        * Type-safe way to represent and implement functions over a recursive data type as self-contained modules
    * Pattern matching  

29. **Team Version Control**

30. **Ethical Software Engineering**
